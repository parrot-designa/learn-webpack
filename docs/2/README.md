# tapable 的原理解析

tapable库源码：https://github.com/webpack/tapable/tree/master/lib

## 1. SyncHook

SyncHook是一种同步钩子。它的特点是所有注册的监听器（listeners 或称为 taps）都会按照它们被添加的顺序依次执行，并且每个监听器必须等待前一个监听器执行完毕才能开始执行。这意味着，当一个 SyncHook 被触发时，整个流程会被阻塞直到所有的监听器都执行完成。

* 同步执行：所有注册的函数将按顺序同步执行。这意味着一个函数的执行会阻塞下一个函数的执行，直到当前函数执行完毕。
* 无返回值：SyncHook 的各个监听器函数不需要返回任何值，因为钩子本身不会收集这些返回值。
* 简单性：由于是同步操作，所以 SyncHook 比较简单易懂，易于理解和调试。
* 阻塞性：因为它是同步的，所以如果有一个监听器函数执行时间很长，那么它会影响后续的所有操作，导致整体性能下降。
* 顺序性：监听器的执行顺序是固定的，按照注册的顺序执行。这对于依赖于执行顺序的场景非常有用。

需要注意的是，虽然 SyncHook 对于构建插件化系统或需要顺序执行的场景很有用，但如果在前端应用中大量使用它，尤其是在涉及异步操作的情况下，可能会导致性能问题或阻塞主线程，因此要谨慎使用。

### 支持的注册方法

仅支持tap 不支持 tapAsync tapPromise

### 支持的触发回调的方法

仅支持 call 不支持 callAsync callPromise